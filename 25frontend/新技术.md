框架： 组件设计 函数式组件 代码复用 逻辑复用 webcomponents

低代码： 动态表单 标准化

构建工具： 开发环境提效 vite esbuild

微前端： 前端微服务 linkjs 

跨端技术：（主要是移动端）小程序

可视化： webgl vr swing  

服务端：node

## Thoughts

1. 基于虚拟dom的jsx前端编码方式是更好的一种方式，如果能把浏览器实现的webcomponent技术引入到react框架，跨端能力代码的可移植性将得到提高









## PWA 的优势在哪？ 

- **消息推送**。用户只要允许，即使网页关闭后仍然可以在系统通知栏收到推送消息。 
- **后台加载**。往常的网页应用只要关闭了网页他的生命就结束了，现在引入了一个 Service Worker 的概念，即使网页关闭，PWA 仍然可以在后台运行获取数据更新（当然有限制）。
- **离线使用**。PWA 打开后会缓存一些内容，之后再次访问即使没有网络也可以浏览之前的页面（如同IE时代的离线浏览）。
- **原生应用界面**。在某些情况下 PWA 应用可以隐藏浏览器本身的所有视觉成分，光从UI和UX上看，很容易认为这就是一个原生界面，如下图其实都是PWA而不是原生应用。
- **桌面图标**。PWA只要配上一个图标，再放快捷方式在桌面上（比如一定时间内第二次访问PWA会自动询问是否添加快捷方式到桌面），就真的和原生系统无异了，打开的速度也很快（当然功能不能很庞大）。  

## WebAssembly 

源于Mozilla 发起的 Asm.js 项目，设计补充而非取代 JavaScript， 它是一个二进制格式，容易翻译到原生代码，本地解码速度比 JS 解析快得多，让高性能的 Web 应用在浏览器上运行成为可能，比如视频游戏、计算机辅助设计、视频和图像编辑、科学可视化等等。未来，现有的生产力应用和 JavaScript 框架都有可能使用 WebAssembly，能显著降低加载速度，同时改进运行性能。开发者可以将针对 CPU 密集计算的 WebAssembly 库整合到现有的 Web 应用中。

## 无服务器运算（英语：Serverless computing）

又被称为函数即服务（Function-as-a-Service，缩写为 FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。 国内外此类型产品，诸如 Tencent Serverless、AWS Lambda、Microsoft Azure Functions 等

Serverless是一种架构理念，是指不用创建和管理服务器、不用担心服务器的运行状态（服务器是否在工作等），只需动态申请应用需要的资源，把服务器留给专门的维护人员管理和维护，进而专注于应用开发，提升应用开发效率、节约企业IT成本。传统上使用Kubernetes运行容器，首先需要创建运行容器的Kubernetes服务器集群，然后再创建容器负载。

云容器实例的Serverless Container就是从使用角度，无需创建、管理Kubernetes集群，也就是从使用的角度看不见服务器（Serverless），直接通过控制台、kubectl、Kubernetes API创建和使用容器负载，且只需为容器所使用的资源付费。

FAAS（函数即服务） + BAAS（后台即服务） 可以称为一个完整的 Serverless 的实现，除此之外，还有 PASS（平台即服务）的概念。而通常平台环境都通过容器技术实现，最终都为了达到 NoOps（无人运维），或者至少 DevOps（开发&运维）。

简单介绍一下这几个名词，防止大家被绕晕：

**FAAS** - Function as a service

函数即服务，每一个函数都是一个服务，函数可以由任何语言编写，除此之外不需要关心任何运维细节，比如：计算资源、弹性扩容，而且可以按量计费，且支持事件驱动。业界大云厂商都支持 FAAS，各自都有一套工作台、或者可视化工作流来管理这些函数。

**BAAS** - Backend as a service

后端及服务，就是集成了许多中间件技术，可以无视环境调用服务，比如数据即服务（数据库服务），缓存服务等。虽然下面还有很多 `XASS`，但组成 Serverless 概念的只有 FAAS + BAAS。

**PAAS** - Platform as a service

平台即服务，用户只要上传源代码就可以自动持续集成并享受高可用服务，如果速度足够快，可以认为是类似 Serverless。但随着以 Docker 为代表的容器技术兴起，以容器为粒度的 PASS 部署逐渐成为主流，是最常用的应用部署方式。比如中间件、数据库、操作系统等。

**DAAS** - Data as a service

数据即服务，将数据采集、治理、聚合、服务打包起来提供出去。DASS 服务可以应用 Serverless 的架构。

**IAAS** - Infrastructure as a Service

基础设施即服务，比如计算机存储、网络、服务器等基建设施以服务的方式提供。

**SAAS** - Software as a Service

软件即服务，比如 ERP、CRM、邮箱服务等，以软件为粒度提供服务。

**容器**

容器就是隔离了物理环境的虚拟程序执行环境，而且环境可被描述、迁移。比较热门的容器技术是 Docker。

随着容器数量增多，就出现了管理容器集群的技术，比较有名的容器编排平台是 Kubernetes。容器技术是 Serverless 架构实现的一种选择，也是实现的基础。

## API网关

代理是纯粹的数据透传，协议不会发生变化；网关在数据透传的背景下，还会设计协议的转换，比如上图中用户请求传输到网关的协议是HTTP，通过网关透传到下游则可能已经转换成企业内部的RPC了(比如JSF、Dubbo等企业自研的RPC框架)。

一个API网关的基本功能包含了统一接入、协议适配、流量管理与容错、以及安全防护，这四大基本功能构成了网关的核心功能。网关首要的功能是负责统一接入，然后将请求的协议转换成内部的接口协议，在调用的过程中还要有限流、降级、熔断等容错的方式来保护网关的整体稳定，同时网关还要做到基本的安全防护（防刷控制），以及黑白名单（比如IP白名单）等基本安全措施

 我们使用 eggjs 搭建了一个 api 网关，并对其进行了多轮压测，在并发 xxx 的情况下，qps 达到 xxx，rt 达到 xxx，并跟运维合作建立了应用的监控，可以实时查看应用指标。在压测过程中我们发现，达到 xxx 并发时，内存会爆掉，我们后面联系了 alinode 团队，对应用堆内存进行分析，发现了内存泄漏点 xxx 并修复。

## WebGL

WebGL 运行在电脑的 GPU 中，因此需要使用能在 GPU 上运行的代码，这样的代码需要提供成对的方法，每对方法中的一个叫顶点着色器而另外一个叫做片元着色器，并且使用 GLSL 语言。将顶点着色器和片元着色器连接起来的方法叫做着色程序。

- 顶点着色器

顶点着色器的作用是计算顶点的位置，即提供顶点在裁剪空间中的坐标值 

- 片元着色器

片元着色器的作用是计算图元的颜色值，我们可以将片元着色器大致理解成网页中的像素

- 数据获取方式 在前面我们提到了顶点着色器和片元着色器的概念，而顶点着色器和片元着色器这两个方法的运行都需要有对应的数据，接下来我们一起来了解一下着色器获取数据的四种方式：

  - 属性和缓冲

  缓冲是发送到 GPU 的一些二进制数据序列，通常情况下缓冲数据包括位置、方向、纹理坐标、顶点颜色值等。 当然你可以根据自己的需要存储任何你想要的数据。 属性用于说明如何从缓冲中获取所需数据并将它提供给顶点着色器。

  - 全局变量

  全局变量在着色程序运行前赋值，在运行过程中全局有效。全局变量在一次绘制过程中传递给着色器的值都一样。

  - 纹理

  纹理是一个数据序列，可以在着色程序运行中随意读取其中的数据。一般情况下我们在纹理中存储的大都是图像数据，但你也可以根据自己喜欢存放除了颜色数据以外的其它数据

  - 可变量

  可变量是一种顶点着色器给片元着色器传值的方式

### 小结

WebGL 只关心两件事：裁剪空间中的坐标值和颜色值。使用 WebGL 只需要给它提供这两个东西。 因此我们通过提供两个着色器来做这两件事，一个顶点着色器提供裁剪空间坐标值，一个片元着色器提供颜色值。

## WebGL 工作原理

了解完 WebGL 的一些基本概念，我们可以一起来看看 WebGL 在 GPU 上的工作都做了些什么。正如我们之前了解到的 WebGL 在 GPU 上的工作主要分为两个部分，即顶点着色器所做的工作（将顶点转换为裁剪空间坐标）和片元着色器所做的工作（基于顶点着色器的计算结果绘制像素点）。假如我们需要绘制一个三角形，此时 GPU 上进行的工作便是先调用三次顶点着色器计算出三角形的 3 个顶点在裁剪空间坐标系中的对应位置，并通过变量 gl_Position 保存在 GPU 中，然后调用片元着色器完成每个顶点颜色值的计算，并通过变量 gl_FragColor 将对应的颜色值存储在 GPU 中。完成这些工作后我们已经得到了绘制三角形所需的像素点，最后便是光栅化三角形了。



## others

dubbo + zookeeper	eureka + feign

RocketMQ	Kafka

netty

k8s + docker

